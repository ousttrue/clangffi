local utils = require("clangffi.utils")
local emmy = require("clangffi.emmy")
local types = require("clangffi.types")

local FUNCTION = "fun"

local function get_name(i, name)
    if name and #name > 0 then
        return emmy.escape_symbol(name)
    end
    return string.format("param%s", i)
end

---@class Interface
---@field libs Table<string, string[]>
local Interface = {

    ---@param self Interface
    ---@param link string
    ---@param header string
    push = function(self, link, header)
        local lib = self.libs[link]
        if not lib then
            lib = {}
            self.libs[link] = lib
        end
        table.insert(lib, header)
    end,

    ---@param self Interface
    ---@param path string
    ---@param exporter Exporter
    generate = function(self, path, exporter)
        local w = io.open(path, "wb")

        w:write([[-- this is generated by luajitffi
local ffi = require('ffi')

-- cdef
require('generated.clang.cdef.corecrt')
require('generated.clang.cdef.CXString')
require('generated.clang.cdef.vcruntime')
require('generated.clang.cdef.CXErrorCode')
require('generated.clang.cdef.Index')

local M = {
    libs = {},
}
]])

        -- const
        w:write("M.enums = {\n")
        for header, export_header in pairs(exporter.headers) do
            for i, t in ipairs(export_header.types) do
                if getmetatable(t) == types.Enum then
                    w:write(string.format("    %s = {\n", t.name))
                    for j, v in ipairs(t.values) do
                        w:write(string.format("        %s = ffi.C.%s,\n", v.name, v.name))
                    end
                    w:write("    },\n")
                end
            end
        end
        w:write("}\n")

        -- string, typedef
        for header, export_header in pairs(exporter.headers) do
            for i, t in ipairs(export_header.types) do
                local mt = getmetatable(t)
                if mt == types.Typedef then
                    w:write(string.format("---@class %s\n", t.name))
                elseif mt == types.Struct then
                    w:write(string.format("---@class %s\n", t.name))
                end
            end
        end

        -- functions
        for lib, headers in pairs(self.libs) do
            local _, basename, ext = utils.split_ext(lib)
            local lib_name = basename:sub(1)
            if lib_name:find("lib") == 1 then
                lib_name = lib_name:sub(4)
            end

            w:write(string.format(
                [[
-----------------------------------------------------------------------------
-- %s
-----------------------------------------------------------------------------
local clang = ffi.load('%s')
M.libs.%s = {
]],
                lib,
                basename,
                lib_name
            ))

            for header, export_header in pairs(exporter.headers) do
                if
                    #utils.filter(headers, function(x)
                        return x == header
                    end) > 0
                then
                    for i, f in ipairs(export_header.functions) do
                        if FUNCTION == "wrap" then
                            for j, p in ipairs(f.params) do
                                w:write(string.format("    ---@param %s %s\n", p.name, emmy.get_typename(p.type)))
                            end
                            w:write(string.format("    ---@return %s\n", emmy.get_typename(f.result_type)))
                            local params = table.concat(
                                utils.imap(f.params, function(i, p)
                                    return get_name(i, p.name)
                                end),
                                ", "
                            )
                            w:write(string.format("    %s = function(%s)\n", f.name, params))
                            w:write(string.format("        return %s.%s(%s)\n", lib_name, f.name, params))
                            w:write("    end,\n")
                        else
                            local params = table.concat(
                                utils.imap(f.params, function(i, p)
                                    local s = string.format("%s:%s", get_name(i, p.name), emmy.get_typename(p.type))
                                    return s
                                end),
                                ", "
                            )
                            w:write(
                                string.format("    ---@type fun(%s):%s\n", params, emmy.get_typename(f.result_type))
                            )
                            w:write(string.format("    %s = %s.%s,\n", f.name, lib_name, f.name))
                        end
                    end
                end
            end
        end

        w:write("}\n")
        w:write("return M\n")
        w:close()
    end,
}

---@return Interface
Interface.new = function()
    return utils.new(Interface, {
        libs = {},
    })
end

return Interface
